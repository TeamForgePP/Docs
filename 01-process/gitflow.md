# Работа с ветками и коммитами (Gitflow + Conventional Commits)

## 1. Основные ветки
- **main** — только стабильные релизы (то, что в проде/демо).
- **dev** — интеграция фич, подготовка следующего релиза.

## 2. Рабочие ветки
- **feature/**<id таски>-short-name — новые фичи и улучшения.  
	  Наследуется от: `dev` → PR открывается в `dev`
	  Пример: `feature/123-kanban-dnd`

- **bugfix/**<id таски>-short-name — исправления багов до релиза. 
	  Наследуется от: `dev` → PR открывается в `dev`

- **hotfix/**<описание на пару слов> — срочные правки прода.  
	  Наследуется от: `main` → PR открывается в `main`
	  После, ==обязательно== PR открывается из `main` в `dev`


### Правила нейминга веток
- Латиница, слова через дефис: `feature/add-sprint-roadmap`
- ==Обязательно включать ID задачи==: `feature/[TF-12]-add-sprint-roadmap`

## 3. Pull Request (PR) политика
- Одна задача = одна ветка = один PR
- В `main` и `develop` — **только через PR** (без прямых пушей)
- PR содержит описание **что** сделано, где находятся изменения и **как проверить**
- Ревьюер ==сам== смёржит ветку после того как одобрит ваш PR

## 4. Коммиты — Conventional Commits
Формат: 
`<type>(scope): <short summary>` 
		short summary - пишем на русском

если нужно то дополнительно комментарий к коммиту:
`BREAKING CHANGE`: более развернуто все что вы сделали, пишем на русском 

как делается:
`git commit -m "<type>(scope): <short summary>" -m "BREAKING CHANGE: ваш комментарий"`

Поддерживаемые типы:
- `feat:` — новая функциональность
- `fix:` — исправление ошибки
- `docs:` — документация
- `refactor:` — изменение внутренней структуры без нового функционала
- `test:` — тесты
- `chore:` — служебные задачи
- `build:` — сборка/зависимости
- `style:` — форматирование/стили без логики

Примеры:
- `feat(roadmap): добавить сущность дорожной карты спринта`
- `fix(auth): исправить обработку невалидного refresh токена`
- `docs(api): обновить обзор API для версии v1`
- `refactor(tasks): разделить сервис задач на более мелкие модули`
- `chore(deps): обновить fastapi до версии 0.115`

## 5.  Автоверсионирование
- **`fix:`** → патч-релиз (PATCH)  
    Пример: `fix(auth): исправить обработку невалидного токена`  
    Версия: `1.2.3` → `1.2.4` (x.y.Z)
    
- **`feat:`** → минорный релиз (MINOR)  
    Пример: `feat(roadmap): добавить сущность дорожной карты спринта`  
    Версия: `1.2.3` → `1.3.0` (x.Y.z)
    
- **`feat!:` или `fix!:` + `BREAKING CHANGE` в описании** → мажорный релиз (MAJOR)
	Версия: `1.2.3` → `2.0.0` (X.y.z)

На нашей стадии коммиты вида `feat!` пока что не понадобятся так как версия 1.0.0 = MVP
проекта (наша конечная работа на этот семестр)

**Как пользоваться**
1. Пиши коммиты строго по правилам (`тип(область): комментарий`). 
	Backend'у в этом поможет специальная бибилиотека, а фронту надо самому выдерживать этот стиль
    
2. После мержа в `main` библиотека:
    - Смотрит все коммиты со времени последнего тега.
        
    - Определяет, какая часть версии должна измениться.
        
    - Создаёт новый тег (`vX.Y.Z`).
        
    - Генерирует CHANGELOG.
    
3. Ты получаешь автоматически обновлённую версию пакета и changelog.